# ***************************************************************************
# *                                                                         *
# *   Copyright (c) 2015 - Qingfeng Xia <qingfeng.xia iesensor.com>         *
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU Lesser General Public License (LGPL)    *
# *   as published by the Free Software Foundation; either version 2 of     *
# *   the License, or (at your option) any later version.                   *
# *   for detail see the LICENCE text file.                                 *
# *                                                                         *
# *   This program is distributed in the hope that it will be useful,       *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU Library General Public License for more details.                  *
# *                                                                         *
# *   You should have received a copy of the GNU Library General Public     *
# *   License along with this program; if not, write to the Free Software   *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
# *   USA                                                                   *
# *                                                                         *
# ***************************************************************************

from PyFoam.ThirdParty.six import print_
from PyFoam.RunDictionary.ParsedParameterFile import ParsedParameterFile

from utility import *

"""groups of turbulence models into: laminar, RAS, LES (including DES), DNS
not all RAS/LES models are list, see more at http://www.openfoam.org/features/LES.php
inviscous flow: basic/potentialFoam
"""
kEpsilon_models = set(["kEpsilon", "RNGkEpsilon", "realizableKE", "LaunderSharmaKE"])
kOmega_models = set(["kOmega", "kOmegaSST"])
RAS_turbulence_models = set(["SpalartAllmaras", "LRR", "qZeta"]) | kEpsilon_models | kOmega_models
LES_turbulence_models = set(["SpalartAllmaras", "Smagorinsky", "Smagorinsky2", "SpalartAllmarasIDDES"])
#
supported_turbulence_models = set(['laminar', 'DNS', 'inviscous']) | RAS_turbulence_models | LES_turbulence_models


""" boundaryName 
"""
supported_boundary_types = set([
'pressureInlet',
'velocityInlet',
'outlet',
'freestream',
'wall',
])

"""
paired boundary:  `ls $FOAM_SRC/finiteVolume/fields/fvPatchFields/constraint`
    "side.*"
    {
        type            cyclicAMI;
    }
"""
supported_special_boundary_types = set([
'symmetry',  # planar symmetric, zeroGradient for all
'empty',   # 2D domain, default name is "frontAndBack"
'wedge',   # wedge front and back for an axi-symmetric geometry 
'cyclic',  # Enables two patches to be treated as if they are physically connected
'processor'  # inter-processor boundary, automatically generated by domain destruct tool
])

"""
User defined function for boundary condition like non-uniform velocity profile is not supported by this script
CSV table,  funkySetField, could be used 
<http://cfd.direct/openfoam/user-guide/boundaries/>
"""
supported_boundary_value_types = set([
# `ls $FOAM_SRC/finiteVolume/fields/fvPatchFields/basic`
'fixedValue',
'fixedGradient',
'mixed',
'zeroGradient',
'calculated',
'coupled',  # FSI, conjugate heat transfter
# derived: see more by `ls $FOAM_SRC/finiteVolume/fields/fvPatchFields/derived`
'fixedFluxPressure',
'freeStream',  # far field velocity field
'slip',  # slip wall
'inletOutlet',  # 
'totalPressure',  # a common pressure inlet
'uniformFixedValue'
])  
    
    
class BasicBuilder():
    """ This class contains boundary condition setup for incompressible flow
    """
    supportedBoundaryTypes = supported_boundary_types | supported_special_boundary_types

    def __init__(self,  casePath, 
                        meshPath,
                        solverSettings=getDefaultSolverSettings(),
                        templatePath=getTemplate("simpleFoam"),
                        turbulenceSettings = {'name': 'laminar'},
                        fluidProperties = {'nu', 1e6},  # default to water
                        boundarySettings = [],
                        internalFieldSettings = {}
                ):
        self._casePath = casePath
        self._meshPath = meshPath
        self._templatePath = templatePath
        
        self._solverSettings = solverSettings
        self._turbulenceSettings = turbulenceSettings
        
        self._fluidProperties = fluidProperties  # incompressible only
        
        self._boundarySettings = boundarySettings
        self._internalFieldSettings = internalFieldSettings
        
    def setup(self):
        createCaseFromTemplate(self._casePath, self._templatePath)

    #this API will be used only property set and get are implemented!
    def build(self, rebuilding_case=True, updated_mesh_path=""):
        if rebuilding_case:
            createCaseFromTemplate(self._casePath, self._templatePath)
        if os.path.exists(updated_mesh_path):
            convertMesh(self._casePath, updated_mesh_path, scaling=True)
            self._meshPath = updated_mesh_path
        
        self.setfluidProperties()  # materials properties
        self.setTurbulenceProperties()
        
        self.setBoundaryConditions()
        self.setInternalFields()
        if not self.check():
            print_('case setup check failed, please check dict files')
        #set.setSolverControl()
                
    def check(self):
        """ heatTransfer must has Buoyang = True, and existent of dict
        """
        case = self._casePath
        settings = self._solverSettings
        
        if settings.dynamicMeshing:
            if not os.path.exists(case + os.path.sep + 'constant/dynamicMeshDict'):
                print_()
                return False

        #paired boundary check: cyclic
        return True
        
    def _getFluidProperties(self):
        return self._fluidProperties
    def _setFluidProperties(self, value):
        if value:
            self._fluidProperties = value
        print self._fluidProperties  # dict becomes set() object why?
    fluidProperties = property(_getFluidProperties, _setFluidProperties)
    
    def setFluidProperties(self, settings=None):
        self.setTransportProperties(settings)
    """
    [tutorials/heatTransfer/buoyantBoussinesqSimpleFoam/hotRoom/constant/transportProperties]
    transportModel Newtonian;

    // Laminar viscosity for air
    nu              [0 2 -1 0 0 0 0] 1e-05;

    // Thermal expansion coefficient
    beta            [0 0 0 -1 0 0 0] 3e-03;

    // Reference temperature
    TRef            [0 0 0 1 0 0 0] 300;

    // Laminar Prandtl number
    Pr              [0 0 0 0 0 0 0] 0.9;

    // Turbulent Prandtl number
    Prt             [0 0 0 0 0 0 0] 0.7;
    """
    def setTransportProperties(self, settings=None):
        """ also control the multiphase properties, 
        copy dict file from case template is the preferred way for Nonewtonian fluid
        tutorials/compressible/rhoSimpleFoam: thermophysicalProperties
        tutorials/incompressible/simpleFoam, nonNewtonianIcoFoam: transportProperties
        foam-extend: tutorials/viscoelastic/viscoelasticFluidFoam/Oldroyd-B/constant/viscoelasticProperties
        OpenFoam 3.0, does not need 'nu' before dimension signature, but back-compactible
        """
        if settings and isinstance(settings, dict):
            self._fluidProperties = settings
        
        case = self._casePath
        solver_settings = self._solverSettings
        assert solver_settings.compressible == False
        
        f = ParsedParameterFile(case + "/constant/transportProperties")
        if solver_settings.nonNewtonian:
            print_('Warning: nonNewtonian case setup is not implemented, please edit dict file directly')
        else:
            print f['nu']
            f['transportModel'] = "Newtonian"
            for k in self._fluidProperties:
                if k in set(['nu', 'dynamicViscosity', 'molecularViscosity']):
                    viscosity = self._fluidProperties[k]
                    f['nu'] = "nu [0 2 -1 0 0 0 0] {}".format(viscosity)
        f.writeFile()

    def setBoundaryConditions(self, boundarySettings=None):
        if boundarySettings and isinstance(boundarySettings, list) and len(boundarySettings)>=1:
            self._boundarySettings = boundarySettings
        self.initBoundaryConditions()
        if not len(self._boundarySettings):
            print_("Warning: No boundary condition is defined, please check!")
        for bcDict in self._boundarySettings:
            if bcDict['type'] in supported_special_boundary_types:
               self.setSpecialBoundary(bcDict['type'], bdDict['name']) 
            else:
                assert bcDict['type'] in supported_boundary_types
                if bcDict['type'] == 'pressureInlet':
                    self.setPressureInletBoundary(bcDict)
                elif bcDict['type'] == 'velocityInlet':
                    self.setVelocityInletBoundary(bcDict)
                elif bcDict['type'] == 'outlet':
                    self.setOutletBoundary(bcDict)
                elif bcDict['type'] == 'freestream':
                    self.setFreestreamBoundary(bcDict)
                elif bcDict['type'] == 'wall':
                    self.setWallBoundary(bcDict)
                else:
                    print_("Warning: boundary type: {} is not supported yet and ignored!".format(bcDict['type']))

    def setInternalFields(self, internalFields=None):
        if internalFields:
            self._internalFieldSettings = internalFields  # mapping type like dict
        for var in self._internalFieldSettings:
            f = ParsedParameterFile(self._casePath + "/0/" + var)
            value = self._internalFieldSettings[var]
            if var == "U":
                f["internalField"] = "uniform ({} {} {})".format(value[0], value[1], value[2])
            else:
                f["internalField"] = "uniform {}".format(value)
            f.writeFile()

    ############################## non public API ######################################
    def listVariables(self):
        """ deduce var list rom solver settings or `ls template_case/0/*`
        """
        import glob
        return glob.glob(self._casePath+os.path.sep+"0"+os.path.sep+"*")
        
    def initBoundaryConditions(self):
        """write default value in 'case/0/p' 'case/0/U' and turbulence related var
        #in polyMesh/boundary  "defaultFaces" must be wall type, but mesh conversion does not rename
        """
        bc_names = listBoundaryNames(self._casePath)
        self.initVelocityBoundaryAsWall(bc_names)
        self.initPressureBoundaryAsWall(bc_names)
        self.initTurbulenceBoundaryAsWall(bc_names, self._turbulenceSettings)

    def initVelocityBoundaryAsWall(self, bc_names):
        """incompressible flow has different wall_function: 
        """
        f = ParsedParameterFile(self._casePath + "/0/U")
        for bc in bc_names:
            f["boundaryField"][bc]={}
            f["boundaryField"][bc]["value"]="uniform (0 0 0)"
            f["boundaryField"][bc]["type"]="fixedValue"
        f.writeFile()
        
    def initPressureBoundaryAsWall(self, bc_names):
        """ shared by compressible flow, porous, nonNewtonian flow
        """
        f = ParsedParameterFile(self._casePath + "/0/p")
        for bc in bc_names:
            f["boundaryField"][bc]={}
            f["boundaryField"][bc]["type"]="zeroGradient"  # zeroGradient type does not need 'value'
        f.writeFile()
    
    def setSpecialBoundary(self, dcDict):
        # freestream is kind of like special boundary type like wall, always uniform $internalField
        case = self._casePath
        boundary_type = bcDict['type']
        boundary_name = bcDict['name']
        var_list = self.listVariables()
        for var in var_list:
            f = ParsedParameterFile(case + "/0/" + var)
            if boundary_type == "empty":
                f["boundaryField"]["frontAndBack"] = {}
                f["boundaryField"]["frontAndBack"]["type"] = "empty"  # empty for all patches, 2D as a special case of 3D mesh
            elif boundary_type == "symmetry":
                f["boundaryField"][boundary_name] = {}
                f["boundaryField"][boundary_name]["type"] = "symmetryPlane"
            elif boundary_type == "cyclic":
                f["boundaryField"][boundary_name] = {}
                f["boundaryField"][boundary_name]["type"] = "cyclic"  
                # "cyclicACM" for Rotating, "cyclicACMI" slidingMesh
            elif boundary_type == "wedge":
                f["boundaryField"][boundary_name] = {}
                f["boundaryField"][boundary_name]["type"] = "wedge"  # axis-sym
            else:
                raise Exception('Boundary or patch type {} is not supported'.format(boundary_type))
            f.writeFile()

    def setCyclicBoundary(self, type, names):
        """inGroups 1(cyclicAMI); neighbourPatch <ref to the paired patch name>
        #boundary file needs to be modified, 
        'transform' = roational, rotationAxis. rotatingCentre
        'transform' = translational; separationVector = 
        """
        pass

    def setPressureInletBoundary(self, bcDict):
        # value is MPa in FreeCAD, but Pa is needed in OpenFOAM
        bcName = bcDict['name']
        inlet_type = bcDict['valueType']
        value = bcDict['value']
        if 'turbulenceSettings' in bcDict:
            turbulenceSettings = bcDict['turbulenceSettings']
        else:
            turbulenceSettings = self._turbulenceSettings
        
        f = ParsedParameterFile(self._casePath + "/0/p")
        f["boundaryField"][bcName] = {}
        if inlet_type == "totalPressure":
            f["boundaryField"][bcName]["type"] = 'totalPressure'
            f["boundaryField"][bcName]["p0"] = 'uniform {}'.format(value)
            f["boundaryField"][bcName]["gamma"] = 0
            f["boundaryField"][bcName]["value"] = "$internalField"
        else:
            f["boundaryField"][bcName]["type"] = 'fixedValue'
            f["boundaryField"][bcName]["value"] = "uniform {}".format(value)
        f.writeFile()
        # velocity intial value is default to wall, uniform 0, so it needs to change
        f = ParsedParameterFile(self._casePath + "/0/U")
        f["boundaryField"][bcName] = {}
        f["boundaryField"][bcName]["type"] = "zeroGradient"
        f.writeFile()
        #
        self.setInletTurbulence(bcName, turbulenceSettings)

    def setVelocityInletBoundary(self, bcDict):
        """ direction: by default, normal to inlet boundary
        """
        bcName = bcDict['name']
        inlet_type = bcDict['valueType']
        value = bcDict['value']
        if 'turbulenceSettings' in bcDict:
            turbulenceSettings = bcDict['turbulenceSettings']
        else:
            turbulenceSettings = self._turbulenceSettings
        
        # velocity intial value is default to wall: uniform (0,0,0)
        f = ParsedParameterFile(self._casePath + "/0/U")
        f["boundaryField"][bcName] = {}  # compressible flow only?
        if inlet_type == "flowRateInletVelocity":
            f["boundaryField"][bcName]["type"] = inlet_type
            f["boundaryField"][bcName]["massFlowRate"] = value  # kg/s
            f["boundaryField"][bcName]["value"] = "$internalField"
        else:
            assert len(value) == 3  # velocity must be a tuple or list with 3 components
            f["boundaryField"][bcName]["type"] = "fixedValue"
            f["boundaryField"][bcName]["value"] = "uniform {}".format(formatValue(value))
        f.writeFile()
        
        f = ParsedParameterFile(self._casePath + "/0/p")
        f["boundaryField"][bcName] = {}
        f["boundaryField"][bcName]["type"] = "zeroGradient"
        f.writeFile()
        #
        self.setInletTurbulence(bcName, turbulenceSettings)
        
    """
    tutorials/incompressible/simpleFoam/airFoil2D/0.org/
    """
    def setFreestreamBoundary(self, bcDict):
        print_('internalField must be set for each var in 0/ folder')
        bcName = bcDict['name']
        value = bcDict['value']
        if 'turbulenceSettings' in bcDict:
            turbulenceSettings = bcDict['turbulenceSettings']
        else:
            turbulenceSettings = self._turbulenceSettings
        #
        f = ParsedParameterFile(self._casePath + "/0/p")
        f["boundaryField"][bcName] = {}
        f["boundaryField"][bcName]["type"] = "freestreamPressure"
        f.writeFile()
        #
        f = ParsedParameterFile(self._casePath + "/0/U")
        f["boundaryField"][bcName] = {}
        f["boundaryField"][bcName]["type"] = "freestream"
        f["boundaryField"][bcName]["value"] = "uniform {}".format(formatValue(value))
        f.writeFile()
        #
        for var in listTurbulenceVariable(turbulenceSettings['name']):
            f = ParsedParameterFile(self._casePath + "/0/" + var)
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "freestream"
            f["boundaryField"][bcName]["freestreamValue"] = "$internalField"
            f.writeFile()
        #turbulence inlet may need extra setting up
        if 'turbulenceSettings' in bcDict:
            turbulenceSettings = bcDict['turbulenceSettings']
        else:
            turbulenceSettings = self._turbulenceSettings
        #setInletTurbulence(self, bcName, turbulenceSettings)  # to check!!!

    """
    special wall boundary: slip wall, moving wall velocity, roughness
    for heat transfer: thickness, mateial, 
    Also some special turbulence setting
    """
    def setWallBoundary(self, bcDict):
        pass


    def setOutletBoundary(self, bcDict):
        """supported_outlet_types: outFlow, pressureOutlet
        pressureOutlet, for exit to background static pressure
        outFlow: corresponding to velocityInlet/FlowRateInlet
        self.supported_outlet_types = set([])
        """
        bcName = bcDict['name']
        outlet_type = bcDict['valueType']
        value = bcDict['value']
        if 'turbulenceSettings' in bcDict:
            turbulenceSettings = bcDict['turbulenceSettings']
        else:
            turbulenceSettings = self._turbulenceSettings

        f = ParsedParameterFile(self._casePath + "/0/p")
        f["boundaryField"][bcName] = {}
        if outlet_type == "pressureOutlet" or outlet_type == "fixedValue":
            f["boundaryField"][bcName]["type"] = "fixedValue"  # totalPressure
            f["boundaryField"][bcName]["value"] = "uniform {}".format(value)
        elif outlet_type == "outFlow":
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] ="$internalField"
        else:
            #default to zeroGradient, for velocityOutlet
            f["boundaryField"][bcName]["type"] = "zeroGradient"
            print_("pressure bundary default to zeroGradient for outlet type '{}' ".format(outlet_type))
        f.writeFile()
        # velocity intial value is default to wall, uniform 0, so it needs to change
        f = ParsedParameterFile(self._casePath + "/0/U")
        f["boundaryField"][bcName] = {}
        if outlet_type == "outFlow":
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] ="$internalField"
        if outlet_type == "freesteam":
            f["boundaryField"][bcName]["type"] = "freestream"
            f["boundaryField"][bcName]["freestreamValue"] = "$internalField"
        else:
            print_("velocity bundary set to inletOutlet for outlet type '{}' ".format(outlet_type))
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] ="$internalField"
        f.writeFile()
        #
        self.setOutletTurbulence(bcName, turbulenceSettings)

    ###################################################################################
    """
    kEpsilon model in 2.1.x: tutorials/incompressible/simpleFoam/turbineSiting/constant/RASProperties
    kEpsilonCoeffs
    {
        Cmu         0.09;
        C1          1.44;
        C2          1.92;
        C3          -0.33;
        sigmak      1.0;
        sigmaEps    1.11; //Original value:1.44
        Prt         1.0;
    }
    2.3.x 
    //NOTE: See "On the use of the k-Epsilon model in commercial CFD software
    // to model the neutral atmospheric boundary layer". J. of wind engineering
    // and inductrial aerodymanics 95(2007) 355-269 by D.M. Hargreaves and N.G. Wright
    """
    def setTurbulenceProperties(self, turbulenceSettings=None):
        """ see list of turbulence model: http://www.openfoam.org/features/turbulence.php
        OpenFoam V3.0 has unified turbuence setup dic, incompatible with 2.x
        currently only some common RAS models are settable by this script
        """
        if turbulenceSettings:
            self._turbulenceSettings = turbulenceSettings
        case = self._casePath
        turbulanceModelName = self._turbulenceSettings['name']
        f = ParsedParameterFile(case + "/constant/turbulenceProperties")

        if turbulanceModelName =='laminar':
            f['simulationType'] = "laminar"
            if 'RAS' in f:
                del f['RAS']  #clear this content
        elif turbulanceModelName in RAS_turbulence_models:
            f['simulationType'] = "RAS"
            if getFoamVersion()[0] >= 3:
                f['RAS'] = {'RASModel': turbulanceModelName, 'turbulence': "on", 'printCoeffs': "on"}
                if turbulanceModelName == "kEpsilon" and kEpsilonCoeffs in self._turbulenceSettings:
                    f['kEpsilonCoeffs'] = self._turbulenceSettings['kEpsilonCoeffs']
            else:
                fRAS = ParsedParameterFile(case + "/constant/RASProperties")
                fRAS['RASModel'] = turbulanceModelName
                fRAS['turbulence'] = "on"
                fRAS['printCoeffs'] = "on"
                # modify coeff is it is diff from default (coded into source code)
                if turbulanceModelName == "kEpsilon" and kEpsilonCoeffs in self._turbulenceSettings:
                    fRAS['kEpsilonCoeffs'] = self._turbulenceSettings['kEpsilonCoeffs']
                fRAS.writeFile()
        elif turbulanceModelName in LES_turbulence_models:
            if f['simulationType'] != "LES":
                print_("Please set LES turbulence model {} by copy from template file".format(turbulanceModelName))
            #if getFoamVersion()[0] >= 3:
                #pass  # all LES model setup is done in file 'turbulenceProperties'
            #else:
                #fLES = ParsedParameterFile(case + "/constant/LESProperties")
        else:
            print_("Turbulence model {} is not recognised or implemented".format(turbulanceModelName))
        f.writeFile()

    def listTurbulenceVarables(self):
        """specific turbulenceModel name:  kEpsilon, kOmegaSST, SpalartAllmaras
        SpalartAllmaras: incompressible/simpleFoam/airFoil2D
        'mut', used in compressible fluid
        """
        turbulenceModelName = self._turbulenceSettings['name']
        compressible = self._solverSettings.compressible
        
        if compressible:
            viscosity_var = 'mut'
        else:
            viscosity_var = 'nut'
        if turbulenceModelName in ["laminar", "", "inviscous", 'DNS'] :  # no need to generate dict file
            var_list = []  # otherwise, generated from filename in folder case/0/, 
        elif turbulenceModelName in kEpsilon_models:
            var_list = ['k', 'epsilon', viscosity_var, 'nuTilda']
        elif turbulenceModelName in kOmege_models:
            var_list = ['k', 'omega', viscosity_var]
        elif turbulenceModelName == "SpalartAllmaras":
            var_list = ['k', viscosity_var, 'nuTilda']
        elif turbulenceModelName in LES_models:
            var_list = ['k', viscosity_var, 'nuTilda']
        elif turbulenceModelName == "qZeta":  # transient models has different var
            var_list = []  # not supported yet in boundary settings
        else:
            print("Turbulence model {} is not supported yet".format(turbulenceModelName))
        return var_list
    
    def initTurbulenceBoundaryAsWall(self, bc_names, turbulence_model):
        """ set all boundary condition to default: wall, also set wallFunction for each var
        kEpsilonRealizable: tutorials/incompressible/simpleFoam/pipeCyclic/0.org
        appliable to compressible flow: rhoSimpleFoam
        SpalartAllmaras: tutorials/incompressible/simpleFoam/airfoil2d/0.org
        has diff wall function: nutSpalartAllmarasWallFunction
        #includeEtc "caseDicts/setConstraintTypes"
        """
        case = self._casePath
        turbulence_var_list = self.listTurbulenceVarables()
        for var in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/" + var)
            #f["internalField"] = "uniform 0"
            for bc in bc_names:
                f["boundaryField"][bc]={}
                if var == "k":
                    f["boundaryField"][bc]["value"]="uniform 0"
                    f["boundaryField"][bc]["type"]="kqRWallFunction"  # depend on turbulence_model!!! 
                elif var == "epsilon":
                    f["boundaryField"][bc]["value"]="$internalField"
                    f["boundaryField"][bc]["type"]="epsilonWallFunction"  #
                elif var == "omega":
                    f["boundaryField"][bc]["value"]="$internalField"
                    f["boundaryField"][bc]["type"]="omegaWallFunction"  #                 
                elif var == "nut":
                    if  turbulence_model == "SpalartAllmaras":
                        f["boundaryField"][bc]["value"]="uniform 0"
                        f["boundaryField"][bc]["type"]="nutSpalartAllmarasWallFunction"
                    else:
                        f["boundaryField"][bc]["value"]="$internalField"
                        f["boundaryField"][bc]["type"]="nutkWallFunction"  # calculated for other type                    
                elif var == "nuTilda":   # for LES model and SpalartAllmaras
                    f["boundaryField"][bc]["type"]="zeroGradient"  # 'value' not needed, same for LES
                else:
                    raise Exception("Error: turbulent var {} is not recognised".format(var))
            f.writeFile()
            
    def setInletTurbulence(self, bcName, turbulenceSettings):
        """ modeled from case /opt/openfoam30/tutorials/incompressible/simpleFoam/pipeCyclic/0.org
        available turbulentce spec: eddyViscosityRatio or inletTurbulentMixingLength
        """
        case = self._casePath
        turbulence_var_list = self.listTurbulenceVarables()

        if "turbulentIntensity" in turbulenceSettings:
            turbulentIntensity = turbulenceSettings["turbulentIntensity"]
        else:
            turbulentIntensity = 0.05  # 5% default, a reasonable guess
        if "hydrauicDiameter" in turbulenceSettings:
            turbulentMixingLength = 0.5 * turbulenceSettings["hydrauicDiameter"]
        else:
            turbulentMixingLength = 0.1  # in metre, half inlet diam/width
        #print_(turbulence_var_list)
        if 'k' in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/k")
            f["internalField"] = "uniform {}".format(1)
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "turbulentIntensityKineticEnergyInlet"
            f["boundaryField"][bcName]["intensity"] = turbulentIntensity
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'epsilon' in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/epsilon")
            #f["internalField"] = "uniform {}".format(0)
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "turbulentMixingLengthDissipationRateInlet"
            f["boundaryField"][bcName]["mixingLength"] = turbulentMixingLength
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'omega' in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/omega")
            #f["internalField"] = "uniform {}".format(0)
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] = "$internalField"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'nut' in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/nut")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "calculated"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'nuTilda' in turbulence_var_list:
            f = ParsedParameterFile(case + "/0/nuTilda")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "zeroGradient"
            f.writeFile()
            #zeroGradient; same for wall, inlet and outlet

    def setOutletTurbulence(self, bcName, turbulenceSettings):
        case = self._casePath
        turbulence_var_list = self.listTurbulenceVarables()
        if 'k' in turbulence_var_list:
            f = ParsedParameterFile(self._casePath + "/0/k")
            f["internalField"] = "uniform 1"
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] = "$internalField"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'epsilon' in turbulence_var_list:
            f = ParsedParameterFile(self._casePath+ "/0/epsilon")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] = "$internalField"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'omega' in turbulence_var_list:
            f = ParsedParameterFile(self._casePath + "/0/omega")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "inletOutlet"
            f["boundaryField"][bcName]["inletValue"] = "$internalField"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'nut' in turbulence_var_list:
            f = ParsedParameterFile(self._casePath + "/0/nut")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "calculated"
            f["boundaryField"][bcName]["value"] = "$internalField"
            f.writeFile()
        if 'nuTilda' in turbulence_var_list:
            f = ParsedParameterFile(self._casePath + "/0/nuTilda")
            f["boundaryField"][bcName] = {}
            f["boundaryField"][bcName]["type"] = "zeroGradient"
            f.writeFile()
            #zeroGradient; same for wall, inlet and outlet
